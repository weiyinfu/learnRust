
# 垃圾回收
垃圾回收是非常复杂的。必须及时释放不再使用的资源，计算机资源才不会被耗尽。C/C++主张人手动释放，如此简单的一句话实际执行起来却是难得不行。人们需要规划何时释放资源，给人带来了巨大的心智负担。人不仅仅要跟外界的业务逻辑打交道，还要充当计算机资源管理员。不仅要写业务逻辑代码，还要在其中夹杂着资源调配代码。内忧外患让人疲惫不堪，令无数人望而生畏。

鉴于手动管理资源带来的巨大心智负担，垃圾回收机制被提上日程。人只需要申请、创建，而不需要关心释放、回收。这样就把资源管理这个“内忧”解决了，可以把全部注意力放在描述业务逻辑上。自从垃圾回收机制被提出以来，几乎所有的新兴语言都是自带垃圾回收的，Java、Python、Go、JavaScript、C#都是有垃圾回收机制的。

然而，垃圾回收机制并非百利而无一害，它会拖慢程序的运行性能。原来用来跑业务逻辑的算力，需要分出一部分来计算垃圾回收。Python基于引用的垃圾回收存在无法并行的缺点，Java的垃圾回收存在“全局暂停”的缺点。简言之，垃圾回收机制只是解放了人，却加重了计算机的负担，它是一种折中：用计算机的时间来解放人的时间，进一步压榨计算机，解放人。

是否存在一种既解放人、又解放计算机的方法？这样人编程省力，同时计算机省力。计算机省力，程序跑得就快，运行效率就高；人省力，开发效率就高。C/C++是计算机省力的极端，Java、Python是人省力的极端（Python跟Java其实是相似的，它们的差别仅仅在于语法不一样）。现在我们想要设计一种新语言，可以断言，它写起来一定不会比Java、Python更好用，但是一定比Java、Python跑得快。它跑起来一定不会比C/C++快，但是一定要比C/C++写起来方便。

计算机世界中，不同的方法有不同的使用场景，把这些方法折中一下往往能够得到更好的通用性方法。

在人力与算力之间，菜鸡才做选择，大牛全都要。于是，Rust诞生了。

Rust的核心思想是：所有权。一个内存资源何时释放取决于拥有这个内存资源的那个变量。变量在则内存在，变量死则内存释放。一个内存资源只能被一个变量所持有，这就是Rust世界中的黄金法则。
如果变量具有资源的所有权，它自然可以对这个资源进行读操作、写操作。然而其它变量要想访问这个资源，就只能“借用”资源了。借用如果只是读借用，那未免太小气，程序写起来太麻烦，每次执行写操作都需要通过资源所有者来进行。所以，写借用也是必须要有的。综上，借用分为读借用和写借用。

读写两种操作乃是计算机中的一切操作，是世间万物的一切法则。数据库四大操作“增删改查”，“增删改”统称为写操作，“查”就是读操作。一个系统有输入和输出两个端口，输入端口用于写，输出端口用于读。人有眼耳鼻舌身意，眼耳鼻用于输入，舌用于输出。人们对于读写早就想清楚了，提出了读写锁的概念。读锁是共享锁，写锁是独占锁。对一个资源的读操作可以被多个线程同时执行，对一个资源的写操作每一时刻只能被一个线程执行（一起写就会乱套）。

Rust由所有权引出读写借用。在同一时刻，读借用可以被多个变量持有，写借用只能一个变量持有。资源所有者一旦把读借用借出去了，就不能再把写借用借出去了。读读不冲突，读写冲突，写读冲突，写写更冲突。这是永恒的道理。

所有权除了可以“借用”，还可以“转移”。资源所有者可以把资源所有权进行转让，一旦转让出去资源所有者就悬空了。

说到这里，Rust的内容就差不多说完了。从所有权出发，我们推出了“借用”和“转移”。Rust中的三种函数已经呼之欲出了：`f(x:&mut Node)`,`f(x:&Node)`,`f(x:Node)`。三者分别对应：写借用、读借用、所有权转移。

具体怎么实现垃圾回收呢？变量有作用域，当变量离开它所在的作用域时，变量就会死亡，它持有的资源就会被回收，这一切都是通过代码静态分析实现的，编译时编译器会在生成的代码中插入资源释放语句。变量的作用域决定了变量的生命周期，生命周期指从变量的创建、销毁这个时间段。

具体怎么实现借用呢？既然是“借用”，那就不能永远占有，好借好还再借不难。变量向资源所有者“借用”一个变量之后一定是要归还的，资源所有者像一个图书馆管理员一样，它的花名册上清楚地记录着每个“借用者”的变量名、借用类型（读借用还是写借用）、预计归还日期。如上文所说，变量有作用域、存在生命周期，而借用是依附于变量而存在的，所以借用也存在生命周期。借用的生命周期结束的时候，就是借用者“还书”、图书馆管理员勾掉借阅记录的过程。于是，生命周期的概念是Rust需要好好设计的一个东西。

所有权的概念简洁而美好，每个资源都被一个变量所持有。然而，这可能吗？有些复杂的数据结构根本无法做到一个资源只被一个变量所持有，例如双向链表中一个结点被它的上一个和下一个结点同时持有。 所以Rc、RefCell等概念就被提出来了。
 