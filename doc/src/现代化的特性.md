Rust语言产生时间比较晚，这使得它能够博采众家之长，融合了很多现代化语言特性，避免了语言设计上的一些坑。

# 强大无敌的类型推导
当强类型强到能够自动推导出类型来，强类型语言的代码看上去就像弱类型一样简洁美观。  
Rust的类型推导非常强大，很少需要给变量声明类型。

# 变量类型声明后置
`i32 x`与`let x:i32`哪种更好？`i32 f(){}`和`fn f()->i32{}`哪种更好？  
变量类型声明后置让人首先想到的是起好变量名，起好了变量名就确定了主体，我们可以给这个主体做一些修改。不妨称这个原则为“变量名优先”。  
无论做什么事情，先把研究对象、研究主体搞清楚，然后再在它上面修修补补，这才是正道。  
变量名优先这种设计被许多现代语言所采用，例如go、typescript。

# 消灭空指针异常
NULL不再到处存在，一个机制就消除了空指针异常，它要求程序员注意判断空指针异常。

因为空指针没了，所以枚举成为最重要的类型。  
Tony Hoare，null 的发明者，在他 2009 年的演讲 “Null References: The Billion Dollar Mistake” 中曾经说到：
> 我称之为我十亿美元的错误。当时，我在为一个面向对象语言设计第一个综合性的面向引用的类型系统。我的目标是通过编译器的自动检查来保证所有引用的使用都应该是绝对安全的。不过我未能抵抗住引入一个空引用的诱惑，仅仅是因为它是这么的容易实现。这引发了无数错误、漏洞和系统崩溃，在之后的四十多年中造成了数十亿美元的苦痛和伤害。

# 支持元组
Go语言支持return多个值，而实际上只需要return一个元组就能实现。return元组的方式更为简洁、一致。

# 支持解构
这是JavaScript的看家本领。

# 没有异常机制
要么panic，要么不panic。  
错误处理是编程语言的一大板块，目前的语言分成两派。C语言主张返回错误，C++主张抛出异常。类似C语言的包括Go、Rust，类似C++的包括Python、Java、C#、JavaScript。  
异常机制比较省心，但是效率会比返回错误的方式略低。  
异常机制需要为语言引入新东西，而返回错误实现简单、只需要在API层就可以实现。     

# 模块化
use语句可以出现在程序的任意位置，而不仅仅只能放在开头。C/C++的include历史包袱过于沉重、过于古老。Rust的use语句也有访问控制，而C++中的use语句没有访问权限控制。  

# 完善的依赖管理
像Maven一样在本地存在一个本地中心库，库有版本号。

# 支持宏
很少有语言能够如此完善地支持宏，C/C++、Java、C#、Python、Go无一能够做到这一点。Rust吸收了lisp的思想。

* 不写重复代码（DRY，Don't repeat yourself.）。很多时候你需要在一些地方针对不同 的类型实现类似的功能，这时常常可以使用宏来避免重复代码（稍后详述）。
* 领域专用语言（DSL，domain-specific language）。宏允许你为特定的目的创造特定的 语法（稍后详述）。
* 可变接口（variadic interface）。有时你需要能够接受不定数目参数的接口，比如 println!，根据格式化字符串的不同，它需要接受任意多的参数（稍后详述）。

# 支持泛型
Go没有泛型，Rust对泛型提供了完善的支持。  
Java的泛型实现基于类型擦除，实现不够完善。Rust的泛型会在编译时为每种类型真正“泛化”成具体类型。  

# 面向对象
trait机制的设计，在任何地方可以为结构体添加trait，灵活性极强。  
与Go类似，类的方法不再放在类体里面，在任何地方都可以为结构体添加方法。  
组合大于继承，Rust不提供继承机制。  
近来继承作为一种语言设计的解决方案在很多语言中失宠了，因为其时常带有共享多于所需的代码的风险。子类不应总是共享其父类的所有特征，但是继承却始终如此。如此会使程序设计更为不灵活，并引入无意义的子类方法调用，或由于方法实际并不适用于子类而造成错误的可能性。某些语言还只允许子类继承一个父类，进一步限制了程序设计的灵活性。

# 完善的测试
Rust语言提供了开箱即用的测试工具。文档测试、单元测试、集成测试一应俱全。  

# 引用
函数和方法的隐式解引用强制多态。解引用强制多态（deref coercions）是 Rust 在函数或方法传参上的一种便利。其将实现了 Deref 的类型的引用转换为原始类型通过 Deref 所能够转换的类型的引用。当这种特定类型的引用作为实参传递给和形参类型不同的函数或方法时，解引用强制多态将自动发生。这时会有一系列的 deref 方法被调用，把我们提供的类型转换成了参数所需的类型。

解引用强制多态的加入使得 Rust 程序员编写函数和方法调用时无需增加过多显式使用 & 和 * 的引用和解引用。这个功能也使得我们可以编写更多同时作用于引用或智能指针的代码。
