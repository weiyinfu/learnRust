变量因为有作用域，所以存在生命周期。  
是否有必要把生命周期的概念暴露给程序员？

当函数返回一个“借用”时，必须指明这个借用的生命周期。如果函数不返回借用，不需要指明生命周期。
生命周期可以省略的几种情况：
* 函数的每个参数的生命周期各不相同
* 如果函数参数中只有一个引用，那么返回值的生命周期就是这个引用
* 如果是方法，那么返回值的生命周期与self相同


当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。如果返回的引用没有指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值，它将会是一个悬垂引用，因为它将会在函数结束时离开作用域。悬垂引用的典型特征：`xxxx` does not live long enough。函数的返回值不应该是悬垂引用，而应该以转移所有权的方式返回对象。


为什么需要生命周期注解这种东西？生命周期只让编译器明白就可以，为什么需要把生命周期暴露给程序员？对于多个不同输入生命周期的函数，输出生命周期直接取最短的那一个不就可以了吗？

答：因为默认情况下，所有输入引用的生命周期各不相同。而返回值的生命周期必定取其中之一。  
如果直接取生命周期最短的那一个，那么实现上是简单的，Rust也确实不需要把生命周期的概念暴露给程序员了，但是有一种情况无法解决：在局部作用域为全局引用绑定值。

考虑下面的例子，全局变量中有a，b两个变量，现在需要根据局部变量y来决定f函数返回a还是返回b，把f函数的返回结果存储在全局变量x中。  
```plain
let a=String::new();
let b=String::new();
let x;
{
    let y=String::new();
    x=f(&y,&a,&b);
}
println!("{}",x);
```
在上例中，如果Rust默认取最短生命周期，则在语句块这个局部空间内无法给全局引用赋值。Rust引入生命周期就是为了解决这个问题。  

